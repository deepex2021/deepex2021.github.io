# Websocket行情数据

## 简介

### 接入URL

`
wss://ws.deepex.live/kline-api/ws
`

### 数据压缩
WebSocket 行情接口返回的所有数据都进行了 GZIP 压缩，需要 client 在收到数据之后解压。

### 心跳消息
当用户的Websocket客户端连接到DEEP的Websocket服务器后，服务器会定期（当前设为5秒）向其发送ping消息并包含一整数值如下：

`
{"ping": 1595935723334}
`

当用户的Websocket客户端接收到此心跳消息后，应返回pong消息并包含同一整数值：

`
{"pong": 1595935723334}
`

> 订阅

```json
{
    "event": "sub", 
    "params":{
        "channel":"market_$base$quote_kline_1min",
        "cb_id":"10001"
    }
}
```


当Websocket服务器连续3次发送了`ping`消息却没有收到任何一次`pong`消息返回后，服务器将主动断开与此客户端的连接。


> 订阅 响应

```json
{
    "event_rep":"subed",
    "channel":"market_$base$quote_kline_1min",
    "cb_id":"10001",
    "ts":1506584998239,
    "status":"ok"
}
```

### 订阅主题
成功建立与Websocket服务器的连接后，Websocket客户端发送如下请求以订阅特定主题。

`
{
    "event": "sub", 
    "params":{
        "channel":"channel name",
        "cb_id":"id generated by client"
    }
}
`

成功订阅后，Websocket客户端将收到确认。之后, 一旦所订阅的主题有更新，Websocket客户端将收到服务器推送的更新消息（push）

> 取消订阅

```json
{
    "event": "unsub", 
    "params":{
        "channel":"market_$base$quote_kline_1min",
        "cb_id":"10001"
    }
}
```

`
{
    "event": "subed", 
    "channel":"channel name",
    "cb_id":"id generated by client",
    "ts": "timestamp"
    "status": "subscribe status"
}
`

### 取消订阅
客户端取消订阅的格式：

`
{
    "event": "unsub", 
    "params":{
        "channel":"channel name",
        "cb_id":"id generated by client"
    }
}
`

## 订阅-K线行情

### channel
`market_$symbol_kline_$period`

> 订阅

```json
{
    "event":"sub",
    "params":{
        "channel":"market_btcusdt_kline_5min",
        "cb_id":"10001"
    }
}
```
### 订阅参数

| 参数 | 数据类型  | 是否必须  | 描述 | 取值范围 |
| ---- | ------ | ---------- | ---- | ----- |
| channel | string | 是  | 主题 |$symbol: 交易对名称<br>btcusdt,ethusdt ...</br> </br> <br>$period: K线周期</br> <br>1min,5min,15min,30min,60min,1day,1week,1month</br>|
| cb_id | string | 是  | 自定义id      | |

> 响应

```json
{
    "channel":"market_btcusdt_kline_5min",
    "ts":1506584998239,//请求时间
    "tick":{
        "id":1506602880,//时间刻度起始值
        "amount":123.1221,//交易额
        "vol":1212.12211,//交易量
        "open":2233.22,//开盘价
        "close":1221.11,//收盘价
        "high":22322.22,//最高价
        "low":2321.22//最低价
    }
}
```
### 更新数据字段
| 字段 | 数据类型 | 描述 |
|-----|-----|-----|
| id | long  | 时间刻度起始值 |
| amount | float  | 交易额 |
| vol | float  | 交易量 |
| open | float  | 开盘价 |
| close | float  | 收盘价 |
| high | float  | 最高价 |
| low | float  | 最低价 |




## 订阅-24小时行情

### channel
`maket_$symbol_ticker`

> 订阅

```json
{
    "event":"sub",
    "params":{
        "channel":"market_btcusdt_ticker",
        "cb_id":"10002"
    }
}
```

### 订阅参数

| 参数 | 数据类型  | 是否必须  | 描述 | 取值范围 |
| ---- | ------ | ---------- | ---- | ----- |
| channel | string | 是  | 主题 |$symbol: 交易对名称 <br>btcusdt,ethusdt ...</br>|
| cb_id | string | 是  | 自定义id      | |


> 响应

```json
{
    "channel":"market_btcusdt_ticker",
    "ts":1506584998239,//请求时间
    "tick":{
        "id":1506584998,//冗余，无实际意义，时间戳
        "amount":123.1221,//交易额
        "vol":1212.12211,//交易量
        "open":2233.22,//开盘价
        "close":1221.11,//收盘价
        "high":22322.22,//最高价
        "low":2321.22,//最低价
        "rose":-0.2922,//涨幅
        "ts":1506584998239,//数据产生时间
        "lower_frame":"0"
    }
}
```

### 更新数据字段
| 字段 | 数据类型 | 描述 |
|-----|-----|-----|
| id | long  | 时间刻度起始值 |
| amount | float  | 交易额 |
| vol | float  | 交易量 |
| open | float  | 开盘价 |
| close | float  | 收盘价 |
| high | float  | 最高价 |
| low | float  | 最低价 |



##  订阅-市场深度行情数据

### channel
`maket_$symbol_depth_$step`

> 订阅

```json
{
    "event":"sub",
    "params":{
        "channel":"market_btcusdt_depth_step0",
        "cb_id":"10001",
        "asks":150,
        "bids":150
    }
}
```

### 订阅参数

| 参数 | 数据类型  | 是否必须  | 描述 | 取值范围 |
| ---- | ------ | ---------- | ---- | ----- |
| channel | string | 是  | 主题 |$symbol: 交易对名称 <br>btcusdt,ethusdt ...</br> </br> <br>$step: 聚合精度</br> <br> step0: 不聚合 </br> <br>step1: 系统精度可配置</br> <br>step2: 系统精度可配置<br>|
| cb_id | string | 是  | 自定义id      | |
| asks | integer | 否  | 卖盘档位     | |
| bids | integer | 否  | 买盘档位     | |


### 更新数据字段

* 注：第一次订阅成功会立刻返回一次全量数据， 另外server也会定期推个全量数据给前端  避免数据出问题


> 全量盘口响应

```json
{
    "channel":"market_btcusdt_depth_step0",
    "ts":1506584998239,//请求时间
    "tick":{
        "asks":[//卖盘
            [22112.22,0.9332],
            [22112.21,0.2],
        ],
        "buys":[//买盘
            [22111.22,0.9332],
            [22111.21,0.2],
        ]
    }
}
```
#### 全量盘口数据

* 可直接替换原有盘口

| 字段 | 数据类型 | 描述 |
|-----|-----|-----|
| asks | 数组对象  | 卖盘深度 |
| buys | 数组对象  | 买盘深度 |



> 增量盘口响应

```json
{
    "channel":"market_btcusdt_depth_step0",
    "ts":1506584998239,//请求时间
    "tick":{
        "side": "asks", 买卖盘方向  asks： 卖盘  buys: 买盘  
        "price" : 133.55,  盘口对应的某个价格段
        "volume" : 44.22   价格段对应的数量
    }
}
```

#### 增量盘口数据

* 只需要替换价格对应的数量即可， volume=0时删除， price与原有盘口某个价格段的price相等时更新volume, 新的price直接新增

| 字段 | 数据类型 | 描述 |
|-----|-----|-----|
| side | string  | 买卖盘方向 <br>asks: 卖盘</br> <br>buys</br>|
| price | float  | 价格 |
| volume | float  | 数量 |


## 订阅-实时成交信息 

### channel
`maket_$symbol_trade_ticker`


> 订阅

```json
{
    "event":"sub",
    "params":{
        "channel":"market_btcusdt_trade_ticker",
        "cb_id":"10001"
    }
}
```

### 订阅参数

| 参数 | 数据类型  | 是否必须  | 描述 | 取值范围 |
| ---- | ------ | ---------- | ---- | ----- |
| channel | string | 是  | 主题 |$symbol: 交易对名称<br>btcusdt,ethusdt ...</br>|
| cb_id | string | 是  | 自定义id      | |

> 响应

```json
{
    "channel":"market_btcusdt_trade_ticker",
    "ts":1506584998239,//请求时间
    "tick":{
        "id":12121,//data中最大交易ID
        "ts":1506584998239,//data中最大时间
        "data":[
            {
                "id":12121,//交易ID
                "side":"buy",//买卖方向buy,sell
                "price":32.233,//单价
                "vol":232,//数量
                "amount":323,//总额
                "ts":1506584998239,//数据产生时间
                "ds":'2017-09-10 23:12:21'
            },
            {
                "id":12120,//交易ID
                "side":"buy",//买卖方向buy,sell
                "price":32.233,//单价
                "vol":232,//数量
                "amount":323,//总额
                "ts":1506584998239,//数据产生时间
                "ds":'2017-09-10 23:12:21'
            }
        ]
    }
}
```

### 更新数据字段
| 字段 | 数据类型 | 描述 |
|-----|-----|-----|
| id  | long | 交易id |
| side | string  | 买卖盘方向 <br>asks: 卖盘</br> <br>buys</br>|
| price | float  | 成交价格 |
| vol | float  | 成交数量 |
| amount | float  | 成交总额 |
| ts | long  | 成交时间 |
| ds | string  | 日期 |




## 请求-K线历史数据

### channel
`maket_$symbol_kline_$period`

* 增加请求参数endIdx，pageSize（最多300，默认300条数据）,如果endIdx为空，则返回最近300条历史数据


> 订阅

```json
{
    "event":"req",
    "params":{
        "channel":"market_btcusdt_kline_5min",
        "cb_id":"10002",
        "since":"1506602880"
    }
}
```

### 订阅参数

| 参数 | 数据类型  | 是否必须  | 描述 | 取值范围 |
| ---- | ------ | ---------- | ---- | ----- |
| channel | string | 是  | 主题 |$symbol: 交易对名称<br>btcusdt,ethusdt ...</br> </br> <br>$period: K线周期</br> <br>1min,5min,15min,30min,60min,1day,1week,1month</br>|
| cb_id | string | 是  | 自定义id      | |
| since | long | 否 | 自定义id      | since缺省时返回最新300条，有值时返回大于since的最多1小时数据，since有强校验，不能早于当前1小时  since取到59|

> 响应

```json
{
    "event_rep":"rep","channel":"market_btcusdt_kline_5min",
    "cb_id":"10001",
    "since":"1506602880",
    "ts":1506584998239,//请求时间
    "data":[
        {
            "id":1506602880,//时间刻度起始值
            "amount":123.1221,//交易额
            "vol":1212.12211,//交易量
            "open":2233.22,//开盘价
            "close":1221.11,//收盘价
            "high":22322.22,//最高价
            "low":2321.22//最低价
        },
        {
            "id":1506602880,//时间刻度起始值
            "amount":123.1221,//交易额
            "vol":1212.12211,//交易量
            "open":2233.22,//开盘价
            "close":1221.11,//收盘价
            "high":22322.22,//最高价
            "low":2321.22//最低价
        }
    ]
}
```

### 更新数据字段
| 字段 | 数据类型 | 描述 |
|-----|-----|-----|
| id  | long | 交易id |
| vol | float  | 交易量 |
| amount | float  | 交易额 |
| open | long  | 开盘价 |
| close | long  | 收盘价 |
| high | long  | 最高价 |
| low | long  | 最低价 |



## 请求-成交历史数据

### channel
`maket_$symbol_trade_ticker`


> 订阅

```json
{
    "event":"req","params":
    {
        "channel":"market_$base$quote_trade_ticker",
        "cb_id":"自定义",
        "top":200
     }
}
```

### 订阅参数

| 参数 | 数据类型  | 是否必须  | 描述 | 取值范围 |
| ---- | ------ | ---------- | ---- | ----- |
| channel | string | 是  | 主题 |$symbol: 交易对名称<br>btcusdt,ethusdt ...</br>|
| cb_id | string | 是  | 自定义id      | |

> 响应

```json
{
    "event_rep":"rep",
    "channel":"market_btcusdt_trade_ticker",
    "cb_id":"10001",
    "ts":1506584998239,
    "status":"ok",
    "top":200,//最大支持200
    "data":[
        {
            "id":12121,//交易ID
            "side":"buy",//买卖方向buy,sell
            "price":32.233,//单价
            "vol":232,//数量
            "amount":323,//总额
            "ts":1506584998239//数据产生时间
        },
        {
            "id":12120,//交易ID
            "side":"buy",//买卖方向buy,sell
            "price":32.233,//单价
            "vol":232,//数量
            "amount":323,//总额
            "ts":1506584998239,//数据产生时间
            "ds":'2017-09-10 23:12:21'
        }
    ]
}
```
### 更新数据字段
| 字段 | 数据类型 | 描述 |
|-----|-----|-----|
| id  | long | 交易id |
| side | string  | 买卖盘方向 <br>asks: 卖盘</br> <br>buys</br>|
| price | float  | 成交价格 |
| vol | float  | 成交数量 |
| amount | float  | 成交总额 |
| ts | long  | 成交时间 |


## 请求-首页24行情数据

### channel
`review`

> 订阅

```json
{"event":"req","params":{"channel":"review"}}
```
### 订阅参数

| 参数 | 数据类型  | 是否必须  | 描述 | 取值范围 |
| ---- | ------ | ---------- | ---- | ----- |
| channel | string | 是  | 主题 | review|

> 响应

```json
{
   "event_rep": "rep",
   "channel": "review",
   "data": {
        "bchbtc":{
            "amount": 115.968833484,
            "close": 0.07956,
            "high": 0.086323,
            "low": 0.079251,
            "open": 0.086323,
            "rose": -0.07834528,
            "vol": 1393.247
        },
        "btcusdt":{
            "amount": 115.968833484,
            "close": 11110.07956,
            "high": 11120.086323,
            "low": 11000.079251,
            "open": 10999.086323,
            "rose": 110.07834528,
            "vol": 111393.247
        }          
   }
}
```

### 更新数据字段
| 字段 | 数据类型 | 描述 |
|-----|-----|-----|
| amount  | long | 成交额 |
| close  | float  | 收盘价|
| high | float  | 最高价 |
| low | float  | 最低价 |
| open | float  | 开盘价 |
| rose | float  | 涨跌幅 |
| vol | float  | 成交量 |


## open-api Demo（java）


```java

package com.exchange.stats.action;

import java.io.InputStream;
import java.io.UnsupportedEncodingException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Date;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.TreeMap;

import org.apache.commons.httpclient.HttpClient;
import org.apache.commons.httpclient.methods.GetMethod;
import org.apache.commons.httpclient.methods.PostMethod;
import org.apache.commons.io.IOUtils;

public class Main {
    /**
     * @param args
     */
    public static void main(String[] args) {
/** 4个变量，api_key,secret_key */ 
 String api_key = "9750*****************65d1";
 String secret_key = "1c16******************2982";

        /** 封装需要签名的参数 */
        TreeMap<String, String> params = new TreeMap<String, String>();
        params.put("api_key", api_key);
        params.put("time", new Date().getTime() + "");
        /** 拼接签名字符串，md5签名 */
        StringBuilder result = new StringBuilder();
        Set<Entry<String, String>> entrys = params.entrySet();
        for (Entry<String, String> param : entrys) {
            /** 去掉签名字段 */
            if (param.getKey().equals("sign")) {
                continue;
            }https://openapi.deepex.info 

            /** 空参数不参与签名 */
            if (param.getValue() != null) {
                result.append(param.getKey());
                result.append(param.getValue().toString());
            }
        }
        result.append(secret_key);
        String sign = getMD5(result.toString());
        params.put("sign", sign);

        /** http请求 */
        String resultJson = get("https://openapi.deepex.live/open/api/get_trades?symbol=btcusdt", params);
        System.out.println(resultJson);
    }

    /**
     * 通过post来提交数据，带参数的方法
     *
     * @param url    请求地址
     * @param params 参数
     * @return
     */
    public static String post(String url, Map<String, String> params) {
        String str = null;
        try {
            HttpClient client = new HttpClient();
            PostMethod method = new PostMethod(url);
            //设定请求头的样式 
            method.setRequestHeader("Content-Type", "application/x-www-form-urlencoded;charset=utf-8");
            if (params != null && params.size() > 0) {
                for (Map.Entry<String, String> entry : params.entrySet()) {
                    method.setParameter(entry.getKey(), entry.getValue());
                }
            }
            int code = client.executeMethod(method);
            if (code >= 200 && code < 300) {
                InputStream in = method.getResponseBodyAsStream();
                str = IOUtils.toString(in);
            }
        } catch (Exception e) {
// TODO Auto-generated catch block 
            e.printStackTrace();
        }
        return str;
    }

    /**
     * 通过get来提交数据，带参数的方法
     *
     * @param url    请求地址
     * @param params 参数
     * @return
     */
    public static String get(String url, Map<String, String> params) {
        String str = null;
        try {
            if (params != null && params.size() > 0) {
                int x = 1;
                for (Map.Entry<String, String> entry : params.entrySet()) {
                    if (x == 1) {
                        url = url + "?";
                    } else {
                        url = url + "&";
                    }
                    url += entry.getKey() + "=" + entry.getValue();
                    x++;
                }
            }
            HttpClient client = new HttpClient();
            System.out.println("url:::" + url);
            GetMethod method = new GetMethod(url);
            //设定请求头的样式 
            method.setRequestHeader("Content-Type", "application/x-www-form-urlencoded;charset=utf-8");
            int code = client.executeMethod(method);
            if (code >= 200 && code < 300) {
                InputStream in = method.getResponseBodyAsStream();
                str = IOUtils.toString(in);
            }
        } catch (Exception e) {
            // TODO Auto-generated catch block 
            e.printStackTrace();
        }
        return str;
    }

    /**
     * 获取String的MD5值
     *
     * @param info 字符串
     * @return 该字符串的MD5值
     */
    public static String getMD5(String info) {
        try {
            //获取 MessageDigest 对象，参数为 MD5 字符串，表示这是一个 MD5 算法（其他还有 SHA1 算法等）： 
            MessageDigest md5 = MessageDigest.getInstance("MD5");
            
            //update(byte[])方法，输入原数据 
            //类似StringBuilder对象的append()方法，追加模式，属于一个累计更改的过程 
            md5.update(info.getBytes("UTF-8"));
            
            //digest()被调用后,MessageDigest对象就被重置，即不能连续再次调用该方法计算原数据的MD5值。可以手动调用reset()方法重置输入源。 
            //digest()返回值16位长度的哈希值，由byte[]承接 
            byte[] md5Array = md5.digest();
            
            //byte[]通常我们会转化为十六进制的32位长度的字符串来使用,本文会介绍三种常用的转换方法 
            return bytesToHex(md5Array);
        } catch (NoSuchAlgorithmException e) {
            return "";
        } catch (UnsupportedEncodingException e) {
            return "";
        }
    }

    private static String bytesToHex(byte[] md5Array) {
        StringBuilder strBuilder = new StringBuilder();
        for (int i = 0; i < md5Array.length; i++) {
            int temp = 0xff & md5Array[i];
            String hexString = Integer.toHexString(temp);
            if (hexString.length() == 1) {//如果是十六进制的0f，默认只显示f，此时要补上0
                strBuilder.append("0").append(hexString);
            } else {
                strBuilder.append(hexString);
            }
        }
        return strBuilder.toString();
    }

}

```


## ws-api Demo (java) 


```java

package test;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.net.URI;
import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.nio.charset.Charset;
import java.nio.charset.CharsetDecoder;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;
import java.util.HashMap;
import java.util.Map;
import java.util.zip.GZIPInputStream;

import javax.net.ssl.SSLContext;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;

import org.java_websocket.client.DefaultSSLWebSocketClientFactory;
import org.java_websocket.client.WebSocketClient;
import org.java_websocket.drafts.Draft;
import org.java_websocket.drafts.Draft_17;
import org.java_websocket.handshake.ServerHandshake;

/**
 * @author 鲫鱼哥 DateTime:2018年11月22日 下午9:25:20 
 * 建议使用的websocket client版本 
 * <dependency> 
 * <groupId>org.java-websocket</groupId> 
 * <artifactId>Java-WebSocket</artifactId> 
 * <version>1.3.0</version> 
 * </dependency> 
 *
 */
public class WsTest {

    public static void main(String[] args) {
        try {
//wsurl 
            String url = "wss://ws.deepex.live/kline-api/ws";
//历史数据请求参数 
            String reqParam = "{"event":"req","params":{"channel":"market_btcusdt_trade_ticker","cb_id":"btcusdt","top":150}}";
//订阅参数 
            String subParam = "{"event":"sub","params":{"channel":"market_btcusdt_trade_ticker","cb_id":"btcusdt","top":150}}";

//初始化请求历史数据 
            WebSocketUtils wsc = WebSocketUtils.executeWebSocket(url, reqParam);

//订阅实时数据 
            wsc.send(subParam);

//线程不结束，等待新的消息，一般一分钟左右会有新的成交返回
            while (true) {
                Thread.sleep(1000);
            }

        }catch (Exception e) {
            e.printStackTrace();
        }
    }

    static class WebSocketUtils extends WebSocketClient {
        private static WebSocketUtils wsclient = null;
        private String msg = "";

        public WebSocketUtils(URI serverURI) {
            super(serverURI);
        }

        public WebSocketUtils(URI serverUri, Draft draft) {
            super(serverUri, draft);
        }

        public WebSocketUtils(URI serverUri, Map<String, String> headers, int connecttimeout) {
            super(serverUri, new Draft_17(), headers, connecttimeout);
        }

        @Override
        public void onOpen(ServerHandshake serverHandshake) {
            System.out.println("链接已建立");

        }

        @Override
        public void onMessage(String s) {
            System.out.println("收到字符串消息");
        }

        @Override
        public void onClose(int i, String s, boolean b) {
            System.out.println("链接已关闭");
        }

        @Override
        public void onError(Exception e) {
            System.out.println("报错啦");
        }

        @Override
        public void onMessage(ByteBuffer socketBuffer) {
            try {
                String marketStr = byteBufferToString(socketBuffer);
                String market = uncompress(marketStr).toLowerCase();
                if (market.contains("ping")) {
                    System.out.println("收到消息ping："+market);
                    String tmp = market.replace("ping", "pong");
                    wsclient.send(market.replace("ping", "pong"));
                } else {
                    msg = market;
                    System.out.println("收到消息："+msg);
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

        public static Map<String, String> getWebSocketHeaders() throws IOException {
            Map<String, String> headers = new HashMap<String, String>();
            return headers;
        }

        private static void trustAllHosts(WebSocketUtils appClient) {
            TrustManager[] trustAllCerts = new TrustManager[] { new X509TrustManager() {
                public java.security.cert.X509Certificate[] getAcceptedIssuers() {
                    return new java.security.cert.X509Certificate[] {};
                }

                public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {
                }

                public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {
                }
            } };

            try {
                SSLContext sc = SSLContext.getInstance("TLS");
                sc.init(null, trustAllCerts, new java.security.SecureRandom());
                appClient.setWebSocketFactory(new DefaultSSLWebSocketClientFactory(sc));
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        public static WebSocketUtils executeWebSocket(String url,String sendMsg) throws Exception {
            wsclient = new WebSocketUtils(new URI(url), getWebSocketHeaders(), 1000);
            trustAllHosts(wsclient);
            wsclient.connectBlocking();
            wsclient.send(sendMsg);
            return wsclient;
        }

        // buffer 转String 
        public String byteBufferToString(ByteBuffer buffer) {
            CharBuffer charBuffer = null;
            try {
                Charset charset = Charset.forName("ISO-8859-1");
                CharsetDecoder decoder = charset.newDecoder();
                charBuffer = decoder.decode(buffer);
                buffer.flip();
                return charBuffer.toString();
            } catch (Exception ex) {
                ex.printStackTrace();
                return null;
            }
        }

        // 解压缩 
        public String uncompress(String str) throws IOException {
            if (str == null || str.length() == 0) {
                return str;
            }
            ByteArrayOutputStream out = new ByteArrayOutputStream();
            ByteArrayInputStream in = new ByteArrayInputStream(str.getBytes("ISO-8859-1"));
            GZIPInputStream gunzip = new GZIPInputStream(in);
            byte[] buffer = new byte[256];
            int n;
            while ((n = gunzip.read(buffer)) >= 0) {
                out.write(buffer, 0, n);
            }
            return out.toString();
        }

    }
}

```

